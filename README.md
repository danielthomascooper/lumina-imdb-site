# Daniel Cooper - Software Developer Assignment
## Setup
**This requires an up-to-date node and npm version, for install and update instructions see https://docs.npmjs.com/downloading-and-installing-node-js-and-npm**

Clone this repository to your device, move into the `imdb-app` directory, then run
```
> npm install
> npm update
> npm start
```
to start the local server. It should then be accessible on port 3000 (http://localhost:3000/).
## Solution overview
### Technology choice
I have used *ExpressJS* for the server side technology, using regular *Javascript* as the frontend, and *SQLite3* (in particular the `better-sqlite3` package). This allowed for rapid setup using the `express-generator` to generate a skeleton from which I built the application. We use *EJS* (**Embedded** JavaScript, not to be confused with *ExpressJS*) which allows for simple template setups for error handling.
### My solution
I have the following file structure:
```
imdb-app
│   app.js
│   config.js
│   my_db.sqlite
│   package.json
│   package-lock.json
│
├───bin
├───node_modules
├───public
│   ├───assets
│   │       logo.svg
│   │       minus-square.svg
│   │       sad_logo.svg
│   │
│   ├───javascript
│   │       dropdown.js
│   │       movietable.js
│   │       users.js
│   │
│   └───stylesheets
│           style.css
│
├───routes
│       imdb.js
│       index.js
│       movies.js
│
├───services
│       db.js
│       imdb.js
│       movies.js
│
└───views
        error.ejs
        index.ejs
```

- `bin` includes some default setup parameters generated by ExpresssJS.
- `node_modules` contains all the used node modules.
- `public` contains the assets, scripts, and styles for the frontend.
- `routes` contains the router for each page and API endpoint.
- `services` contains all methods that access the database and external API.
- `views` contains all the page templates for the homepage and error page.

I changed the SQL schema slightly to make the id the primary key so it will autoincrement when adding new users in sqlite3.

### Improvements
#### Frontend improvements
Aside from aesthetic improvements, I could improve the scalability to mobile screen sizes using a frontend library e.g. React, which can handle changing screen sizes, along with other advantages if this project were to scale. I could also add a more advanced search system, using the omdbapi search API (http://www.omdbapi.com/?s=guardians&apikey=API_KEY_HERE) to add new movies.

I could alos 

#### Security improvements
I have the API key included in this repository to allow for testing on different machines, which is a clear security issue if this was published to a public repository, but it is not exposed on the front-end by using our own internal endpoint to access the omdb API.

I also need more input validation on both API and user inputs, to ensure they are the correct format. I have made sure to escpae all SQL queries already to avoid SQL injection vulnerabilities.

I could implement a simple password authentication method, storing the salted hashes in a separate table/database.

#### Database improvements
The provided schema has a number of issues with its design
1. The primary key is just an incremented integer, when ideally we would have a unique identifier such as a username because
2. The database cannot identify people sharing names, and so currently we only allow one list per name. This also works on the assuption people have exactly one first and one last name without spaces, and that the concept of first and last names apply to different cultures (see https://en.wikipedia.org/wiki/Personal_name#Eastern_name_order).
3. The favourite movies are stored as a 255 length string, this is a simple requirement to increase the length, but it may make more sense to have each user-movie combination on a new row, which also allows for easier access to information about movie codes without having to use string comprehension. This could also allow for different lists for each user, by creating tables for user information (username <-> first name, last name, etc), user lists (username <-> movie list), and list movies (movie list <-> movie code).
4. We could cache the information obtained from the omdb database, only refreshing when stale. This would dramatically reduce calls to the API, improving loading speeds and reducing quota usage.